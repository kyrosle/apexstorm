```cpp
void ByteArray::writeUint32(uint32_t value) {
  uint8_t tmp[5]; /* 4 byte 32 bit */
  // compression
  uint8_t i = 0;
  while (value >= 0x80) {
    tmp[i++] = (value & 0x7F) | 0x80;
    value >>= 7;
  }
  tmp[i++] = value;
  write(tmp, i);
}
```

decompression:

```cpp
uint32_t ByteArray::readUint32() {
  uint32_t result = 0;
  // decompression
  for (uint8_t i = 0; i < 32; i += 7) {
    uint8_t b = readFuint8();
    if (b < 0x80) {
      result |= ((uint32_t)b) << i;
      break;
    } else {
      result |= (((uint32_t)(b & 0x7f)) << i);
    }
  }
  return result;
}
```
上面的代码展示了 ByteArray 类中的压缩和解压缩方法，这里简要解释一下其实现过程。

`writeUint32()` 方法:

该方法用于将一个 32 位无符号整数压缩为一个可变长度的字节流，并将其写入到 ByteArray 中。该方法先定义了一个大小为 5 的 uint8_t 数组，在 while 循环中对该数组进行填充。对于数值 value，每次从后面的 7 位中取出数值，将最高位标记为 1 表示后面还有数据，将剩下的 7 位标记为数值，写入到 tmp 数组中，直到 value 小于 0x80，这时只将 value 写入 tmp 数组。最后将 tmp 数组写入到 ByteArray 中。

`readUint32()` 方法:

该方法用于将一个可变长度的字节流解压缩为一个 32 位无符号整数，并返回其值。在循环中，每次从 ByteArray 中读取一个字节 b，并将其写入到 result 中，直到 b 小于 0x80，表示不再有数据，将 result 左移 i 位后返回。

总之，该方法展示了字节流的可变长度压缩和解压缩的过程，受益于可变长度的设计，每个数的压缩后长度可能不同，当数字小于 0x80（128）时，即为最后一部分数据，此时不需要再进行标记符号的操作。将其中的高位标记为 1，表示后面还有数据，低七位存放的是数字的实际值。解压缩的过程也十分简单，按照压缩的过程从高位到低位，每次将之前的结果左移 7 位，并将新的低 7 位与之进行或运算，最终得到原来的数。

在上述压缩与解压代码中，0x80 和 0x7F 是用于标记不同数字的符号位和有效位的数字常量。

- 0x80：在压缩的过程中，用于标记高位是否有数字。当待压缩数字中的高 7 位不全为 0 时，该位设置为 1，表示后面还有数字需要压缩；否则设置为 0。在解压缩的过程中，该位被用来判断是否到达了字节流的末尾。
- 0x7F：在压缩的过程中，用于存储有效数据。每个字节暂时只能表示 7 位二进制数字，0x7F 将数字限制在了 7 位以内。在解压缩的过程中，用于取出每个字节中的有效数据。

这里需要注意的是，由于字节的高低位在不同的处理器架构上有不同的存储方式，因此在网络传输或存储数据时，最好使用大端（Big Endian）或小端（Little Endian）存储方式，以确保接收方可以正确读取数据。在本代码中，没有明确指定采用的存储方式，需要确认 ByteArray 的存储方式与压缩前后的数据相同。

假设我们要压缩一个 32 位无符号整数，值为 `0x12345678`，那么它的二进制表示为：

```
0001 0010 0011 0100 0101 0110 0111 1000
```

在压缩的过程中，将该数值转化成可变长度的字节流。按照上述压缩算法，首先取出最后 7 位，即为 `0x58 (01 011000)`, 剩下的高 25 位设置第一个标记位，写入 tmp 数组，得到 `0xD8 0x12`，表示后面还有数字。接着将下一个 7 位 `0x36 (011 0110)` 加上第二个标记位（因为后面还有数字），写入到 tmp 数组中，得到 `0xB6 0x24 0x01`，继续写入下一个 7 位 `0x2` ，写入 tmp 数组中并设置最后一个标记为 0，得到最终的压缩字节流为 `0x82 0xB6 0x24 0x01 0x2`。

接下来，我们使用上述解压缩的算法，将上面压缩出来的字节流解压缩为原来的数值。从最高位开始解压，首先读出第一个字节 `0x82`，它的二进制表示为：

```
1000 0010
```

最高位为 1，说明后面还有字节需要解压，解压出来的有效数字为后 7 位，即为 `0x02`。接着继续读取下一个字节 `0xB6`，它的二进制表示为：

```
1011 0110
```

最高位仍为 1，说明后面还有字节需要解压，取出后 7 位得到 `0x36`，左移 7 位并与前面的有效数字或运算，即 `0x02 | (0x36 << 7) = 0x16A2`。然后继续读取下一个字节 `0x24`，它的二进制表示为：

```
0010 0100
```

最高位为 0，说明后面没有字节需要解压，取出后 7 位得到 `0x24`，左移 14 位并与前面的有效数字或运算，即 `(0x02 | (0x36 << 7)) | (0x24 << 14) = 0x362A02`。最后读取下一个字节 `0x01`，由于它只有 7 位，直接左移 21 位并与前面的有效数字或运算，即 `(0x02 | (0x36 << 7)) | (0x24 << 14) | (0x01 << 21) = 0x12345678`。这样就成功解压出了压缩前的原始数值 `0x12345678`。